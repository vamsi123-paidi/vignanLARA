What is a Promise?

A Promise is a JavaScript object that represents the eventual completion (or failure) of an asynchronous operation.

It has three states:
1. Pending â€“ initial state, neither fulfilled nor rejected.
2. Fulfilled â€“ operation completed successfully.
3. Rejected â€“ operation failed.

Basic Syntax of a Promise
const promise = new Promise((resolve, reject) => {
  // async task
  if (true) {
    resolve("Success message");
  } else {
    reject("Error message");
  }
});


const checkAge = new Promise((resolve, reject) => {
  const age = 20;
  if (age >= 18) {
    resolve("Access granted"); // Success
  } else {
    reject("Access denied"); // Error
  }
});
// Handling the promise
checkAge
  .then((message) => {
    console.log(message); // Runs if resolved
  })
  .catch((error) => {
    console.error(error); // Runs if rejected
  });

Example 1: A Simple Promise

const myPromise = new Promise((resolve, reject) => {
  let value = 5;
  if (value > 3) {
    resolve("Value is greater than 3 âœ…");
  } else {
    reject("Value is too small âŒ");
  }
});

myPromise
  .then((message) => console.log("Resolved:", message))
  .catch((error) => console.log("Rejected:", error));


Example 2: Simulating API Delay

function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = true;
      if (success) {
        resolve("Data fetched successfully ðŸ“¦");
      } else {
        reject("Failed to fetch data âŒ");
      }
    }, 2000);
  });
}

fetchData()
  .then((data) => console.log(data))
  .catch((err) => console.log(err));


Chaining Promises

function step1() {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Step 1 done");
      resolve();
    }, 1000);
  });
}

function step2() {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Step 2 done");
      resolve();
    }, 1000);
  });
}

step1()
  .then(() => step2().then())
  .then(() => console.log("All steps completed âœ…"));

Why Use Promises?

- Better than nested callbacks (callback hell)
- Easier error handling with `.catch()`
- Can be used with `async/await` for cleaner syntax

callback hell Example recreation using Promises
function waitAndLog(message, delay) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(message);
      resolve();
    }, delay);
  });
}
console.log("Start");
waitAndLog("1st step done", 1000)
  .then(() => waitAndLog("2nd step done", 1000))
  .then(() => waitAndLog("3rd step done", 1000))
  .then(() => waitAndLog("4th step done", 1000));

// 1. Validate order structure
function validateOrder(order) {
  return new Promise((resolve, reject) => {
    if (!order.customerId) {
      reject(new Error('Customer ID is required'));
    } else if (!order.items || order.items.length === 0) {
      reject(new Error('Order must contain items'));
    } else {
      console.log('âœ… Order validated');
      resolve(order);
    }
  });
}

// 2. Check inventory availability
function checkInventory(order) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log('ðŸ“¦ Inventory checked');
      order.inventoryVerified = true;
      resolve(order);
    }, 800);
  });
}

// 3. Process payment
function processPayment(order) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const paymentSuccess = Math.random() > 0.2; // 80% success rate
      if (paymentSuccess) {
        console.log('ðŸ’³ Payment processed');
        order.paymentStatus = 'completed';
        resolve(order);
      } else {
        reject(new Error('Payment declined'));
      }
    }, 1200);
  });
}

// Execute the pipeline
validateOrder({
  customerId: 'cust789',
  items: [{ id: 'prod456', qty: 1 }]
})
.then(checkInventory)
.then(processPayment)
.then(order => {
  console.log('ðŸŽ‰ Order completed:', order);
})
.catch(err => {
  console.error('âŒ Order failed:', err.message);
});

Handling Multiple Orders (Promise.all)
Explanation: Shows how to process multiple orders concurrently and wait for all to complete.
function processSingleOrder(orderId) {
  return new Promise(resolve => {
    const processTime = 500 + Math.random()*100+2000;
    setTimeout(() => {
      resolve({
        orderId,
        status: 'processed',
        processTime: Math.round(processTime)
      });
    }, processTime);
  });
}

const orderBatch = ['order101','order102','order103','order104'];

// Process all orders in parallel
Promise.all(orderBatch.map(processSingleOrder))
  .then(results => {
    console.log('All orders processed:');
    console.table(results);
    const totalTime = results.reduce((sum, order) => sum + order.processTime, 0);
    console.log(`Total processing time: ${totalTime}ms`);
  })
  .catch(error => {
    console.error('Batch processing failed:', error);
  });


Examples based on microtask and macrotasks

 âœ… Example 1

console.log('A');
setTimeout(() => {
  console.log('B');
}, 0);
Promise.resolve().then(() => {
  console.log('C');
});
console.log('D');


Output:


A
D
C
B



 âœ… Example 2

console.log(1);
setTimeout(() => {
  console.log(2);
}, 0);
Promise.resolve().then(() => {
  console.log(3);
});
console.log(4);


Output:


1
4
3
2



 âœ… Example 3

Promise.resolve().then(() => {
  console.log('First');
});
console.log('Second');
setTimeout(() => {
  console.log('Third');
}, 0);
console.log('Fourth');


Output:


Second
Fourth
First
Third



 âœ… Example 4

setTimeout(() => {
  console.log('setTimeout');
}, 0);
Promise.resolve().then(() => {
  console.log('promise');
});
queueMicrotask(() => {
  console.log('microtask');
});
console.log('sync');


Output:


sync
promise
microtask
setTimeout


> ðŸ’¡ `Promise.then` and `queueMicrotask` are both microtasks, executed in order after sync code.


 âœ… Example 5

console.log('one');
setTimeout(() => {
  console.log('two');
}, 0);
Promise.resolve().then(() => {
  console.log('three');
}).then(() => {
  console.log('four');
});
console.log('five');


Output:


one
five
three
four
two



 âœ… Example 6

setTimeout(() => {
  console.log('A');
}, 1000);
setTimeout(() => {
  console.log('B');
}, 0);
Promise.resolve().then(() => {
  console.log('C');
});
Promise.resolve().then(() => {
  console.log('D');
});


Output:


C
D
A
B



 âœ… Example 7

Promise.resolve().then(() => {
  console.log('Promise 1');
  return Promise.resolve('Inner');
}).then((val) => {
  console.log(val);
});
console.log('Sync');

Output:


Sync
Promise 1
Inner



 âœ… Example 8

setTimeout(() => {
  console.log('timeout 1');
}, 0);
Promise.resolve().then(() => {
  console.log('promise 2');
});
setTimeout(() => {
  console.log('timeout 2');
}, 0);
Promise.resolve().then(() => {
  console.log('promise 1');
});


Output:


promise 2
promise 1
timeout 1
timeout 2



 âœ… Example 9

console.log('Start');

queueMicrotask(() => {
  console.log('Microtask 1');
});
Promise.resolve().then(() => {
  console.log('Promise then');
});
console.log('End');


Output:


Start
End
Microtask 1
Promise then



 âœ… Example 10

console.log('Start');
setTimeout(() => {
  console.log('Timeout');
}, 0);
Promise.resolve().then(() => {
  console.log('Promise');
});
queueMicrotask(() => {
  console.log('Microtask');
});
console.log('End');


Output:


Start
End
Promise
Microtask
Timeout



ðŸ”¥ Example 11 â€“ Nested Promises & Microtask inside `then`

console.log('1');

Promise.resolve().then(() => {
  console.log('2');
  queueMicrotask(() => {
    console.log('3');
  });
  return Promise.resolve();
}).then(() => {
  console.log('4');
});

console.log('5');


 âœ… Output:


1
5
2
3
4


 ðŸ§  Why?

 `1`, `5` â†’ sync
 `2` â†’ first microtask
 `queueMicrotask(...)` is scheduled during `2`, runs after
 `4` â†’ chained `.then()`
 `3` â†’ finally, `queueMicrotask`



ðŸ”¥ Example 12 â€“ Microtask inside a Macrotask

console.log('A');
setTimeout(() => {
  console.log('B');
  queueMicrotask(() => {
    console.log('C');
  });
  Promise.resolve().then(() => {
    console.log('D');
  });
  console.log('E');
}, 0);
console.log('F');


 âœ… Output:


A
F
B
E
C
D


 ðŸ§  Why?

 `A`, `F` â†’ sync
 `setTimeout(...)` callback starts â†’ logs `B`, `E`
 Inside that callback:

   `.then(...)` & `queueMicrotask()` go into microtask queue
 `D`, `C` â†’ microtasks from within macrotask



ðŸ”¥ Example 13 â€“ Mixed chaining & nested microtasks

console.log('start');
Promise.resolve().then(() => {
  console.log('promise 1');
  queueMicrotask(() => {
    console.log('microtask 1');
  });
  return Promise.resolve('inner');
}).then((val) => {
  console.log(val);
  queueMicrotask(() => {
    console.log('microtask 2');
  });
});
console.log('end');


 âœ… Output:


start
end
promise 1
microtask 1
inner
microtask 2




ðŸ”¥ Example 14 â€“ Recursive microtasks

console.log('X');
queueMicrotask(() => {
  console.log('Y');
  queueMicrotask(() => {
    console.log('Z');
  });
});
console.log('W');


 âœ… Output:


X
W
Y
Z


 ðŸ§  Explanation:

 Microtasks can enqueue other microtasks, but they won't interrupt current ones â€” theyâ€™ll run in the next microtask cycle.



ðŸ”¥ Example 15 â€“ Macrotask enqueues microtask which enqueues another microtask

setTimeout(() => {
  console.log('1');
  queueMicrotask(() => {
    console.log('2');
    queueMicrotask(() => {
      console.log('3');
    });
  });
  console.log('4');
}, 0);
console.log('5');


 âœ… Output:


5
1
4
2
3




ðŸ”¥ Example 16 â€“ Promise inside microtask

queueMicrotask(() => {
  console.log('A');

  Promise.resolve().then(() => {
    console.log('B');
  });

  console.log('C');
});

console.log('D');


 âœ… Output:


D
A
C
B




ðŸ”¥ Example 17 â€“ Microtask chain explosion

console.log('start');

Promise.resolve().then(() => {
  console.log('1');
  return Promise.resolve().then(() => {
    console.log('2');
  });
}).then(() => {
  console.log('3');
});

console.log('end');


 âœ… Output:


start
end
1
2
3




ðŸ”¥ Example 18 â€“ Microtask > Macrotask even when deeply nested

setTimeout(() => {
  console.log('T1');
}, 0);
Promise.resolve().then(() => {
  console.log('P1');
  setTimeout(() => {
    console.log('T2');
  }, 0);
  return Promise.resolve().then(() => {
    console.log('P2');
  });
}).then(() => {
  console.log('P3');
});
console.log('S');


 âœ… Output:


S
P1
P2
P3
T1
T2




ðŸ”¥ Example 19 â€“ `queueMicrotask` inside `.then` vs direct

Promise.resolve().then(() => {
  console.log('A');
  queueMicrotask(() => {
    console.log('B');
  });
});
queueMicrotask(() => {
  console.log('C');
});
console.log('D');


 âœ… Output:


D
A
C
B







